<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SENKU - Implementaci칩n con Canvas</title>
    <!-- Carga de Tailwind CSS para estilos de interfaz -->
    <script src="https://cdn.tailwindcss.com"></script>
   <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f4f8; /* Fondo de la p치gina */
            font-family: 'Inter', sans-serif;
            /* Evita la selecci칩n de texto en todo el cuerpo, eliminando el desplazamiento en drag */
            user-select: none; 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            /* FIX CR칈TICO: Evita que el scroll "salga" del contenido, deteniendo el desplazamiento fantasma */
            overscroll-behavior: none;
            /* Asegura que no haya scroll horizontal en el cuerpo */
            overflow-x: hidden;
        }

        #game-container {
            position: relative; 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            overflow: hidden; 
            max-width: fit-content;
            background-color: #ffffff; /* Contenedor blanco para el tablero */
            padding: 1rem; /* p-4 */
        }
        
        /* Contenedor que mantiene el espacio del canvas (630px) + sus dimensiones de estabilidad (4px) = 634px para evitar CLS */
        #canvas-wrapper {
            position: relative;
            width: 634px; 
            height: 634px; 
        }

        #solitaire-canvas {
            /* Posici칩n normal (dentro del flujo) para evitar el desplazamiento no deseado */
            display: block;
            margin: 0; /* Asegura que no haya margen extra */
            
            border-radius: 10px;
            cursor: pointer;
            
            /* Fondo SVG COMPLETAMENTE CODIFICADO */
            background-image: url('data:image/svg+xml,<svg%20width="630"%20height="630"%20viewBox="0%200%20630%20630"%20xmlns="http://www.w3.org/2000/svg"><path%20d="M%20200%202%20L%20430%202%20A%2020%2020%200%200%201%20450%2020%20L%20450%20180%20L%20610%20180%20A%2020%2020%200%200%201%20628%20200%20L%20628%20430%20A%2020%2020%200%200%201%20610%20450%20L%20450%20450%20L%20450%20610%20A%2020%2020%200%200%201%20430%20628%20L%20200%20628%20A%2020%2020%200%200%201%20180%20610%20L%20180%20450%20L%2020%20450%20A%2020%2020%200%200%201%202%20430%20L%202%20200%20A%2020%2020%200%200%201%2020%20180%20L%20180%20180%20L%20180%2020%20A%2020%2020%200%200%201%20200%202%20Z"%20fill="%238f6fdb"%20stroke="%23000000"%20stroke-width="5"/><defs><circle%20id="hole"%20r="25"%20fill="%23333333"/></defs><use%20href="%23hole"%20x="225"%20y="45"/>%20<use%20href="%23hole"%20x="315"%20y="45"/>%20<use%20href="%23hole"%20x="405"%20y="45"/>%20<use%20href="%23hole"%20x="225"%20y="135"/>%20<use%20href="%23hole"%20x="315"%20y="135"/>%20<use%20href="%23hole"%20x="405"%20y="135"/>%20<use%20href="%23hole"%20x="45"%20y="225"/>%20<use%20href="%23hole"%20x="135"%20y="225"/>%20<use%20href="%23hole"%20x="225"%20y="225"/>%20<use%20href="%23hole"%20x="315"%20y="225"/>%20<use%20href="%23hole"%20x="405"%20y="225"/>%20<use%20href="%23hole"%20x="495"%20y="225"/>%20<use%20href="%23hole"%20x="585"%20y="225"/>%20<use%20href="%23hole"%20x="45"%20y="315"/>%20<use%20href="%23hole"%20x="135"%20y="315"/>%20<use%20href="%23hole"%20x="225"%20y="315"/>%20<use%20href="%23hole"%20x="315"%20y="315"/>%20<use%20href="%23hole"%20x="405"%20y="315"/>%20<use%20href="%23hole"%20x="495"%20y="315"/>%20<use%20href="%23hole"%20x="585"%20y="315"/>%20<use%20href="%23hole"%20x="45"%20y="405"/>%20<use%20href="%23hole"%20x="135"%20y="405"/>%20<use%20href="%23hole"%20x="225"%20y="405"/>%20<use%20href="%23hole"%20x="315"%20y="405"/>%20<use%20href="%23hole"%20x="405"%20y="405"/>%20<use%20href="%23hole"%20x="495"%20y="405"/>%20<use%20href="%23hole"%20x="585"%20y="405"/>%20<use%20href="%23hole"%20x="225"%20y="495"/>%20<use%20href="%23hole"%20x="315"%20y="495"/>%20<use%20href="%23hole"%20x="405"%20y="495"/>%20<use%20href="%23hole"%20x="225"%20y="585"/>%20<use%20href="%23hole"%20x="315"%20y="585"/>%20<use%20href="%23hole"%20x="405"%20y="585"/></svg>');
            background-color: transparent; /* Permite que el SVG se vea */
            background-repeat: no-repeat;
            background-position: center;
            
            user-select: none; 
            outline: none; 
            /* Desactiva la manipulaci칩n t치ctil predeterminada */
            touch-action: none; 
        }

        /* FIX CR칈TICO: Estabilidad total para evitar cambios de layout al actualizar el mensaje */
        #status-message {
            height: 24px; /* h-6 en Tailwind */
            line-height: 24px;
            /* Fija el ancho m치ximo y corta el texto para evitar la expansi칩n del contenedor padre */
            max-width: 100%; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
        }
    </style>
</head>
<body>

  <div id="game-container" class="p-4 bg-white">
    <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">Solitario de Fichas (SENKU)</h1>
    
        <div id="canvas-wrapper" class="mb-4">
      <canvas id="solitaire-canvas" width="630" height="630" draggable="false"></canvas>
    </div>

    <div id="status-message" class="text-center text-lg font-semibold text-blue-600">
      Selecciona una ficha para empezar.
    </div>
    
    <div class="text-center text-sm text-gray-500 mt-2">
      Fichas restantes: <span id="peg-count" class="font-bold text-gray-700">32</span>
    </div>

    <button id="reset-button" class="mt-6 w-full py-2 bg-indigo-600 text-white font-bold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150">
      Reiniciar Juego
    </button>
  </div>

  <script>
    // --- Variables Globales del Juego ---
    
    // Estado inicial del tablero
    const INITIAL_BOARD = [
      [9, 9, 1, 1, 1, 9, 9], 
      [9, 9, 1, 1, 1, 9, 9], 
      [1, 1, 1, 1, 1, 1, 1], 
      [1, 1, 1, 0, 1, 1, 1], 
      [1, 1, 1, 1, 1, 1, 1], 
      [9, 9, 1, 1, 1, 9, 9], 
      [9, 9, 1, 1, 1, 9, 9] 
    ];
    
    let tablero = JSON.parse(JSON.stringify(INITIAL_BOARD)); // Clonar el tablero inicial
    let fichaArrastrandose = null; // { row, col } de la ficha seleccionada
    let isDragging = false;
    let mouseX = 0;
    let mouseY = 0;
    let validTargets = []; // Almacena { row, col } de los destinos v치lidos
    let hoverTarget = null; // Almacena { row, col } del destino sobre el que se est치

    // --- Configuraci칩n y Contexto del Canvas ---
    const CANVAS_SIZE = 630; 
    const GRID_SIZE = 7;
    const CELL_SIZE = CANVAS_SIZE / GRID_SIZE; // 90px
    
    // --- Par치metros de Ficha y Estilos ---
    const PEG_RADIUS = 25; 
    const PEG_COLOR = '#a7f3d0'; 
    const PEG_STROKE_COLOR = '#065f46'; 
    const PEG_STROKE_WIDTH = 3; 
    const SELECTED_PEG_COLOR = PEG_STROKE_COLOR; 
    
    // --- Nuevos Estilos de Feedback ---
    const TARGET_RING_COLOR = '#d1e7dd'; // Verde claro para el destino posible
    const HOVER_RING_COLOR = '#409c69'; // Verde m치s oscuro para el destino "hovered"

    let canvas;
    let ctx;
    
    const statusMessage = document.getElementById('status-message');
    const pegCountDisplay = document.getElementById('peg-count');
    
    // --- Funciones de Ayuda para Dibujar en Canvas ---
    
    /**
    * Dibuja un c칤rculo en coordenadas de PIXEL.
    */
    function dibujarCircleAtCoords(x, y, radius, fillColor, strokeColor, strokeWidth, shadow = true) {
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      
      if (shadow) {
        ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 5;
      }
      
      if (strokeWidth > 0) {
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = strokeWidth;
        ctx.stroke();
      }
      
      ctx.fillStyle = fillColor;
      ctx.fill();
      
      ctx.shadowColor = 'transparent'; 
    }

    /**
    * Calcula el centro en p칤xeles de una celda de la cuadr칤cula.
    */
    function getCellCenter(row, col) {
      const centerX = col * CELL_SIZE + CELL_SIZE / 2;
      const centerY = row * CELL_SIZE + CELL_SIZE / 2;
      return { centerX, centerY };
    }
    
    /**
    * Dibuja una ficha (peg) en la cuadr칤cula.
    */
    function dibujarPeg(row, col, color = PEG_COLOR, hasShadow = true) {
      const { centerX, centerY } = getCellCenter(row, col);
      dibujarCircleAtCoords(centerX, centerY, PEG_RADIUS, color, PEG_STROKE_COLOR, PEG_STROKE_WIDTH, hasShadow);
    }

    /**
    * Dibuja el c칤rculo de destino resaltado.
    */
    function dibujarTargetRing(row, col, color) {
      const { centerX, centerY } = getCellCenter(row, col);
      // Dibujamos el anillo sin relleno, solo borde.
      ctx.beginPath();
      ctx.arc(centerX, centerY, PEG_RADIUS * 1.2, 0, Math.PI * 2);
      
      // Sombra sutil para destacar
      ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 3;
      
      ctx.strokeStyle = color;
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // Resetear la sombra
      ctx.shadowColor = 'transparent'; 
    }


    /**
    * Dibuja todo el tablero.
    */
    function dibujarTablero() {
      ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

      // 1. Dibujar los Anillos de Destino V치lidos (si hay una ficha seleccionada)
      if (fichaArrastrandose) {
        for (const target of validTargets) {
          // Determinar color: HOVER si el puntero est치 sobre este destino, TARGET_RING si no.
          const color = (hoverTarget && target.row === hoverTarget.row && target.col === hoverTarget.col) 
            ? HOVER_RING_COLOR 
            : TARGET_RING_COLOR;
          dibujarTargetRing(target.row, target.col, color);
        }
      }


      // 2. Dibujar las Fichas (estado '1' en la matriz)
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (tablero[r][c] === 1) {
            
            const isSelected = fichaArrastrandose && fichaArrastrandose.row === r && fichaArrastrandose.col === c;

            // Si estamos arrastrando (isDragging) NO dibujamos el peg en la posici칩n original.
                        // Si est치 seleccionado pero NO arrastrando, lo dibujamos en la posici칩n original.
                        if (isDragging && isSelected) {
                            continue; // No la dibujamos, se dibujar치 despu칠s como ficha flotante
                        }

                        if (isSelected) {
                            // Usamos dibujarPeg con hasShadow = false para un efecto de 'pulsado' o 'incrustado'
                            // Mantiene el color PEG_COLOR y el borde PEG_STROKE_COLOR
                            dibujarPeg(r, c, PEG_COLOR, false); 
                        } else {
                            // Ficha normal
                            dibujarPeg(r, c, PEG_COLOR, true);
                        }
                        

//             const color = isSelected ? SELECTED_PEG_COLOR : PEG_COLOR;
//             // Una ficha seleccionada (sin arrastrar) se dibuja en el color s칩lido, sin sombra y sin borde para un efecto "pulsado".
//             if (isSelected) {
//               const { centerX, centerY } = getCellCenter(r, c);
//               // Dibujar el peg seleccionado sin borde ni sombra
//               dibujarCircleAtCoords(centerX, centerY, PEG_RADIUS, SELECTED_PEG_COLOR, 'transparent', 0, false);
//             } else {
//               dibujarPeg(r, c, color);
//             }
          } 
        }
      }
      // 3. Dibujar el peg flotante 칔LTIMO (con color y borde original, y con sombra)
            if (isDragging) {
                // Usamos PEG_COLOR, PEG_STROKE_COLOR, y PEG_STROKE_WIDTH para que parezca el peg original
                dibujarCircleAtCoords(
                    mouseX, 
                    mouseY, 
                    PEG_RADIUS, 
                    PEG_COLOR,          // <-- 춰CAMBIAR AQU칈! Relleno verde claro original
                    PEG_STROKE_COLOR,   // <-- 춰CAMBIAR AQU칈! Borde oscuro original
                    PEG_STROKE_WIDTH,   // <-- 춰CAMBIAR AQU칈! Ancho del borde original
                    true                // Mantenemos la sombra para que parezca que est치 flotando
                ); 
            }
    }


    /**
    * Determina los destinos v치lidos para una ficha en (fromRow, fromCol).
    */
    function getValidMoves(fromRow, fromCol) {
      const moves = [
        { dr: 0, dc: 2 }, { dr: 0, dc: -2 }, 
        { dr: 2, dc: 0 }, { dr: -2, dc: 0 } 
      ];
      
      const valid = [];

      for (const move of moves) {
        const tr = fromRow + move.dr;
        const tc = fromCol + move.dc;
        const jr = fromRow + move.dr / 2;
        const jc = fromCol + move.dc / 2;

        // 1. Check de l칤mites para destino
        if (tr >= 0 && tr < GRID_SIZE && tc >= 0 && tc < GRID_SIZE) {
          // 2. Check: Destino est치 vac칤o y es una celda jugable (no '9')
          if (tablero[tr][tc] === 0) {
            // 3. Check: Celda intermedia tiene una ficha ('1')
            if (tablero[jr][jc] === 1) {
              valid.push({ row: tr, col: tc });
            }
          }
        }
      }
      return valid;
    }

    /**
    * Intenta mover la ficha. (L칩gica de movimiento del c칩digo original)
    */
    function moverFicha(fromRow, fromCol, toRow, toCol) {
      // Buscamos si el destino est치 en la lista precalculada de destinos v치lidos
      const isValidTarget = validTargets.some(target => target.row === toRow && target.col === toCol);

      if (!isValidTarget) {
        statusMessage.textContent = "Movimiento. inv치lido: destino no es un salto legal.";
        return false;
      }
      
      // La ficha intermedia est치 garantizada por getValidMoves
      const dRow = toRow - fromRow;
      const dCol = toCol - fromCol;
      const jumpedRow = fromRow + dRow / 2;
      const jumpedCol = fromCol + dCol / 2;

      // Realizar el movimiento (Actualizar el estado L칍GICO del tablero)
      tablero[toRow][toCol] = 1;   
      tablero[fromRow][fromCol] = 0; 
      tablero[jumpedRow][jumpedCol] = 0; 

      statusMessage.textContent = `춰Movimiento exitoso!`;
      
      checkGameStatus();
      return true;
    }


    // --- L칩gica de Interacci칩n (Eventos del Puntero) ---

    function getGridCoordinates(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const canvasX = clientX - rect.left;
      const canvasY = clientY - rect.top;

      const col = Math.floor(canvasX / CELL_SIZE);
      const row = Math.floor(canvasY / CELL_SIZE);

      return { row, col, canvasX, canvasY };
    }

    /**
    * Inicia el arrastre (pointerdown handler).
    */
    function handleStart(e) {
      e.preventDefault(); 
      e.stopPropagation(); 
      
      if (e.pointerId !== undefined) {
        canvas.setPointerCapture(e.pointerId);
      }

      const { row, col, canvasX, canvasY } = getGridCoordinates(e.clientX, e.clientY);

      if (isDragging) return;

      if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE && tablero[row][col] === 1) {
        fichaArrastrandose = { row, col };
        
        // *** NUEVA L칈NEA CLAVE: Pre-calcular destinos v치lidos ***
        validTargets = getValidMoves(row, col);
        
        if (validTargets.length === 0) {
          statusMessage.textContent = "Ficha seleccionada. No tiene movimientos v치lidos.";
        } else {
          statusMessage.textContent = `Ficha seleccionada. Hay ${validTargets.length} destinos posibles.`;
        }
        
        mouseX = canvasX;
        mouseY = canvasY;
        
        dibujarTablero(); 
      } else {
        // Si no seleccionamos una ficha, aseguramos que el estado de destino est칠 limpio
        validTargets = [];
        fichaArrastrandose = null;
        dibujarTablero(); // Para limpiar visualmente
        statusMessage.textContent = "Selecciona una ficha para empezar.";
      }
      
      document.documentElement.scrollLeft = 0;
      document.body.scrollLeft = 0;
    }
    
    /**
    * Maneja el arrastre visual (pointermove handler).
    */
    function handleMove(e) {
      e.stopPropagation(); 
      
      if (!fichaArrastrandose) return;

      if (isDragging) {
        만.preventDefault();
      }

      const { row: startRow, col: startCol } = fichaArrastrandose;
      const { canvasX, canvasY, row: currentGridRow, col: currentGridCol } = getGridCoordinates(e.clientX, e.clientY);
      
      if (!isDragging) {
        const { centerX: startX, centerY: startY } = getCellCenter(startRow, startCol);
        
        const distanceSq = (canvasX - startX)**2 + (canvasY - startY)**2;
        const MIN_DRAG_DISTANCE_SQ = 100; // 10px al cuadrado
        
        if (distanceSq > MIN_DRAG_DISTANCE_SQ) {
          isDragging = true;
          // Al confirmar el drag, limpiamos el status para no estorbar
          statusMessage.textContent = "Arrastrando... Suelta sobre un c칤rculo de destino.";
        } else {
          return; 
        }
      }

      // L칩gica de Detecci칩n de Hover (Solo si estamos arrastrando)
      let newHoverTarget = null;
      
      // Solo hacemos hover si la casilla actual est치 dentro de los destinos v치lidos.
      const isOverValidTarget = validTargets.some(target => 
        target.row === currentGridRow && target.col === currentGridCol
      );

      if (isOverValidTarget) {
        newHoverTarget = { row: currentGridRow, col: currentGridCol };
      }

      // Solo redibujamos si el hover state ha cambiado
      if (!hoverTarget || !newHoverTarget || hoverTarget.row !== newHoverTarget.row || hoverTarget.col !== newHoverTarget.col) {
        hoverTarget = newHoverTarget;
        dibujarTablero();
      }
      
      mouseX = canvasX;
      mouseY = canvasY;
      
      // Redibujar el peg flotante incluso si el hover no ha cambiado
      // Solo necesitamos llamar a dibujarTablero si el peg flotante no est치 dibujado a칰n,
      // pero para simplificar, redibujamos si el estado de arrastre est치 activo.
      if (isDragging) {
        dibujarTablero();
      }

      canvas.style.cursor = 'grabbing';
    }


    /**
    * Finaliza el arrastre e intenta el movimiento (pointerup handler).
    */
    function handleEnd(e) {
      if (!fichaArrastrandose) return;
      
      e.preventDefault(); 
      e.stopPropagation(); 
      
      const pointerId = e.pointerId;

      const { row: fromRow, col: fromCol } = fichaArrastrandose;
      const { row: toRow, col: toCol } = getGridCoordinates(e.clientX, e.clientY);
      
      const wasDragging = isDragging;
      isDragging = false; 
      hoverTarget = null; // Limpiar el estado de hover

      canvas.style.cursor = 'pointer';

      if (fromRow === toRow && fromCol === toCol && !wasDragging) {
        // Click simple para deseleccionar
        statusMessage.textContent = "Ficha deseleccionada.";
      } else if (wasDragging) {
        // Intento de movimiento
        moverFicha(fromRow, fromCol, toRow, toCol);
      } else {
        // Drag fallido en la misma casilla
        statusMessage.textContent = "Arrastre cancelado.";
      }
      
      // Resetear estados L칍GICOS y forzar el redibujo.
      fichaArrastrandose = null;
      validTargets = []; // Limpiar los destinos visuales
      dibujarTablero(); 

      document.documentElement.scrollLeft = 0;
      document.body.scrollLeft = 0;

      if (pointerId !== undefined) {
        canvas.releasePointerCapture(pointerId);
      }
    }
    
    /**
    * Maneja cuando el navegador interrumpe la interacci칩n.
    */
    function handleCancel(e) {
      e.preventDefault();
      e.stopPropagation();
      
      isDragging = false;
      fichaArrastrandose = null;
      validTargets = []; // Limpiar destinos
      hoverTarget = null; // Limpiar hover
      canvas.style.cursor = 'pointer';
      statusMessage.textContent = "Acci칩n cancelada. Selecciona una ficha.";
      dibujarTablero();
      
      document.documentElement.scrollLeft = 0;
      document.body.scrollLeft = 0;

      if (e.pointerId !== undefined) {
        canvas.releasePointerCapture(e.pointerId);
      }
    }


    // --- L칩gica del Juego y Control de Flujo ---

    function checkGameStatus() {
      let pegCount = 0;
      let possibleMoves = 0;

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (tablero[r][c] === 1) {
            pegCount++;
            possibleMoves += getValidMoves(r, c).length;
          }
        }
      }
      
      pegCountDisplay.textContent = pegCount; // Actualizar el contador visible

      // L칩gica de fin de juego
      if (possibleMoves === 0) {
        // Desactivar interacci칩n
        canvas.removeEventListener('pointerdown', handleStart);
        canvas.removeEventListener('pointerup', handleEnd);
        canvas.removeEventListener('pointermove', handleMove); 
        canvas.removeEventListener('pointercancel', handleCancel); 

        if (pegCount === 1) {
          statusMessage.textContent = `游꿀 춰Ganaste! 춰Solo queda 1 ficha!`;
        } else {
          statusMessage.textContent = `游띔 춰Juego terminado! Quedaron ${pegCount} fichas.`;
        }
      }
    }

    function resetGame() {
      tablero = JSON.parse(JSON.stringify(INITIAL_BOARD)); // Clonar el estado inicial
      fichaArrastrandose = null;
      isDragging = false;
      validTargets = [];
      hoverTarget = null;
      
      dibujarTablero();
      statusMessage.textContent = "Tablero reiniciado. Selecciona una ficha.";
      
      // Re-a침adir listeners (eliminar primero en caso de que el juego estuviera terminado)
      canvas.removeEventListener('pointerdown', handleStart);
      canvas.removeEventListener('pointerup', handleEnd);
      canvas.removeEventListener('pointermove', handleMove);
      canvas.removeEventListener('pointercancel', handleCancel);

      canvas.addEventListener('pointerdown', handleStart);
      canvas.addEventListener('pointerup', handleEnd);
      canvas.addEventListener('pointermove', handleMove);
      canvas.addEventListener('pointercancel', handleCancel);

      document.documentElement.scrollLeft = 0;
      document.body.scrollLeft = 0;

      checkGameStatus();
    }

    // --- Inicializaci칩n ---

    window.onload = function() {
      canvas = document.getElementById('solitaire-canvas');
      ctx = canvas.getContext('2d');
      
      canvas.addEventListener('pointerdown', handleStart);
      canvas.addEventListener('pointerup', handleEnd);
      canvas.addEventListener('pointermove', handleMove);
      canvas.addEventListener('pointercancel', handleCancel); 
      
      canvas.addEventListener('dragstart', (e) => e.preventDefault());

      document.getElementById('reset-button').addEventListener('click', resetGame);

      dibujarTablero();
      checkGameStatus();
    };

  </script>
</body>
</html>
